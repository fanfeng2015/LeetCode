package substringWithConcatenationOfAllWords;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

// LeetCode #30

// You are given a string, s, and a list of words, words, 
// that are all of the same length. 
// Find all starting indices of substring(s) in s that is a 
// concatenation of each word in words exactly once and without
// any intervening characters.

public class SubstringWithConcatenationOfAllWords {

	// Solution 1
	public List<Integer> findSubstring(String s, String[] words) {
		List<Integer> result = new ArrayList<>();
		int m = s.length(), n = words.length, k = words[0].length();
		if (m < n * k) {
			return result;
		}
		// there could be duplicate words
		Map<String, Integer> map = new HashMap<>();
		for (String word : words) {
			Integer count = map.get(word);
			count = count == null ? 1 : count + 1;
			map.put(word, count);
		}
		for (int i = 0; i <= m - n * k; i++) {
			Map<String, Integer> copy = new HashMap<>(map);
			if (isConcatenationOfAllWords(copy, s.substring(i, i + n * k), words)) {
				result.add(i);
			}
		}
		return result;
	}

	private boolean isConcatenationOfAllWords(Map<String, Integer> map, String substring, String[] words) {
		int n = words.length, k = words[0].length();
		for (int i = 0; i < n; i++) {
			String str = substring.substring(i * k, (i + 1) * k);
			Integer count = map.get(str);
			if (count == null) {
				return false;
			} else {
				map.put(str, count - 1);
				if (count == 1) {
					map.remove(str);
				}
			}
		}
		return true; // always return true if this point is reached
	}

	// Time complexity is O(m*n*k).
	// Space complexity is O(n).

	// Solution 2: optimization
	public List<Integer> findSubstring(String s, String[] words) {
		List<Integer> result = new ArrayList<>();
		int m = s.length(), n = words.length, k = words[0].length();
		if (m < n * k) {
			return result;
		}
		// there could be duplicate words
		Map<String, Integer> map = new HashMap<>();
		for (String word : words) {
			Integer count = map.get(word);
			count = count == null ? 1 : count + 1;
			map.put(word, count);
		}
		for (int i = 0; i < k; i++) {
			int total = 0;
			Map<String, Integer> temp = new HashMap<>();
			for (int left = i, right = i; right + k <= m; right += k) {
				String str = s.substring(left, right + k);
				if (!map.containsKey(str)) {
					// invalid word, start over again from (end + k)
					total = 0;
					temp = new HashMap<>();
					left = right + k;
				} else {
					Integer count = temp.get(str);
					count = count == null ? 1 : count + 1;
					temp.put(str, count);
					if (temp.get(str) <= map.get(str)) {
						total++;
					}
					while (temp.get(str) > map.get(str)) {
						String wordOnTheLeft = s.substring(left, left + k);
						temp.put(wordOnTheLeft, temp.get(wordOnTheLeft) - 1);
						left += k;
						if (temp.get(wordOnTheLeft) < map.get(wordOnTheLeft)) {

						}
					}
				}
			}
		}
	}
}
